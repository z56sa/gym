import os
import asyncio
import sqlite3
import re
from datetime import datetime, timedelta
from dotenv import load_dotenv

import discord
from discord import app_commands
from discord.ext import commands, tasks

load_dotenv()
TOKEN = os.getenv('TOKEN')
PREFIX = os.getenv('PREFIX', '!')
LOG_CHANNEL_ID = int(os.getenv('LOG_CHANNEL_ID')) if os.getenv('LOG_CHANNEL_ID') else None
WELCOME_MSG = os.getenv('WELCOME_MSG', 'Ù…Ø±Ø­Ø¨Ø§Ù‹ {user}ØŒ Ø£Ù‡Ù„Ø§Ù‹ Ø¨Ùƒ ÙÙŠ Ø§Ù„Ø³ÙŠØ±ÙØ±!')
GUILD_ID = int(os.getenv('GUILD_ID')) if os.getenv('GUILD_ID') else None

if not TOKEN:
    print('Ø¶Ø¹ TOKEN ÙÙŠ Ù…Ù„Ù .env Ø«Ù… Ø£Ø¹Ø¯ ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨Ø±Ù†Ø§Ù…Ø¬')
    raise SystemExit(1)

intents = discord.Intents.default()
intents.message_content = True
intents.members = True
intents.guilds = True

bot = commands.Bot(command_prefix=PREFIX, intents=intents)

# Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
conn = sqlite3.connect('data.db')
cursor = conn.cursor()

cursor.execute('''CREATE TABLE IF NOT EXISTS warnings (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    guild_id TEXT,
    user_id TEXT,
    moderator_id TEXT,
    reason TEXT,
    timestamp INTEGER
)''')

cursor.execute('''CREATE TABLE IF NOT EXISTS tickets (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    guild_id TEXT,
    user_id TEXT,
    channel_id INTEGER
)''')

cursor.execute('''CREATE TABLE IF NOT EXISTS economy (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    guild_id TEXT,
    user_id TEXT,
    balance INTEGER DEFAULT 0,
    xp INTEGER DEFAULT 0,
    level INTEGER DEFAULT 1,
    last_xp_time INTEGER DEFAULT 0
)''')

conn.commit()

# Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø­Ù…Ø§ÙŠØ©
SPAM_LIMIT = 5      
SPAM_SECONDS = 10   
MUTE_DURATION = 60  
LINKS_ALLOWED_ROLES = []  
CB_NAME = 'CB'      

user_messages = {}

async def log_action(guild: discord.Guild, text: str):
    if not LOG_CHANNEL_ID:
        return
    channel = guild.get_channel(LOG_CHANNEL_ID)
    if channel:
        try:
            await channel.send(text)
        except Exception:
            pass

async def ensure_muted_role(guild: discord.Guild) -> discord.Role:
    role = discord.utils.get(guild.roles, name='Muted')
    if role:
        return role
    role = await guild.create_role(name='Muted', reason='Role for muting members')
    overwrite = discord.PermissionOverwrite()
    overwrite.send_messages = False
    overwrite.speak = False
    for ch in guild.channels:
        try:
            await ch.set_permissions(role, overwrite=overwrite)
        except Exception:
            pass
    return role

def is_mod_check(obj):
    perms = None
    if isinstance(obj, commands.Context):
        perms = obj.author.guild_permissions
    elif isinstance(obj, discord.Interaction):
        perms = obj.user.guild_permissions
    return perms and (perms.kick_members or perms.ban_members or perms.manage_guild or perms.moderate_members)

def save_welcome(msg: str):
    try:
        with open('.welcome', 'w', encoding='utf-8') as f:
            f.write(msg)
    except Exception:
        pass

def load_welcome():
    global WELCOME_MSG
    if os.path.exists('.welcome'):
        try:
            with open('.welcome', 'r', encoding='utf-8') as f:
                WELCOME_MSG = f.read()
        except Exception:
            pass

load_welcome()

@bot.event
async def on_ready():
    print(f'Logged in as {bot.user} (ID: {bot.user.id})')
    if GUILD_ID:
        try:
            guild = discord.Object(id=GUILD_ID)
            await bot.tree.sync(guild=guild)
            print('Synced app commands to guild', GUILD_ID)
        except Exception as e:
            print('Failed to sync to guild:', e)
    else:
        try:
            await bot.tree.sync()
            print('Synced global app commands')
        except Exception as e:
            print('Failed to sync global commands (might take 1 hour):', e)
    cleanup_spam_cache.start()

@bot.event
async def on_member_join(member: discord.Member):
    try:
        channel = member.guild.system_channel or discord.utils.get(member.guild.text_channels, permissions=member.guild.me.guild_permissions)
        msg = WELCOME_MSG.replace('{user}', member.mention)
        if channel:
            await channel.send(msg)
            await log_action(member.guild, f'ðŸ‘‹ Ù…Ø±Ø­Ø¨Ø§Ù‹ {member} (Ø¯Ø®ÙˆÙ„ Ø¬Ø¯ÙŠØ¯)')
    except Exception:
        pass

@bot.event
async def on_message(message):
    if message.author.bot or not message.guild:
        return await bot.process_commands(message)
    now = datetime.utcnow().timestamp()
    user_id = (message.guild.id, message.author.id)
    timestamps = user_messages.get(user_id, [])
    timestamps = [t for t in timestamps if now - t < SPAM_SECONDS]
    timestamps.append(now)
    user_messages[user_id] = timestamps
    if len(timestamps) > SPAM_LIMIT:
        try:
            muted_role = await ensure_muted_role(message.guild)
            await message.author.add_roles(muted_role, reason='Spam mute')
            await message.channel.send(f'{message.author.mention} ØªÙ… ÙƒØªÙ…Ùƒ Ù…Ø¤Ù‚ØªØ§Ù‹ Ø¨Ø³Ø¨Ø¨ Ø§Ù„Ø³Ø¨Ø§Ù… Ù„Ù…Ø¯Ø© {MUTE_DURATION} Ø«Ø§Ù†ÙŠØ©.')
            await log_action(message.guild, f'ðŸ”‡ **{message.author}** ØªÙ… ÙƒØªÙ…Ù‡ Ù…Ø¤Ù‚ØªØ§Ù‹ Ø¨Ø³Ø¨Ø¨ Ø§Ù„Ø³Ø¨Ø§Ù…')
            await asyncio.sleep(MUTE_DURATION)
            await message.author.remove_roles(muted_role, reason='Spam mute expired')
            await log_action(message.guild, f'ðŸ”Š **{message.author}** ØªÙ… ÙÙƒ Ø§Ù„ÙƒØªÙ… Ø¨Ø¹Ø¯ Ø§Ù†ØªÙ‡Ø§Ø¡ Ø§Ù„Ø³Ø¨Ø§Ù…')
        except Exception:
            pass
        return
    if re.search(r'https?://', message.content):
        allowed = False
        for role in message.author.roles:
            if role.name in LINKS_ALLOWED_ROLES:
                allowed = True
                break
        if not allowed:
            try:
                await message.delete()
                await message.channel.send(f'{message.author.mention} Ù…Ù…Ù†ÙˆØ¹ Ø¥Ø±Ø³Ø§Ù„ Ø±ÙˆØ§Ø¨Ø· Ù‡Ù†Ø§.')
                await log_action(message.guild, f'ðŸš« **{message.author}** Ø­Ø§ÙˆÙ„ Ø¥Ø±Ø³Ø§Ù„ Ø±Ø§Ø¨Ø· ÙˆØªÙ… Ø§Ù„Ø­Ø°Ù')
            except Exception:
                pass
            return
    cursor.execute('SELECT balance, xp, level, last_xp_time FROM economy WHERE guild_id=? AND user_id=?',
                   (str(message.guild.id), str(message.author.id)))
    row = cursor.fetchone()
    now_ms = int(now * 1000)
    if row is None:
        cursor.execute('INSERT INTO economy (guild_id, user_id, balance, xp, level, last_xp_time) VALUES (?, ?, 0, 0, 1, 0)',
                       (str(message.guild.id), str(message.author.id)))
        conn.commit()
        balance, xp, level, last_time = 0, 0, 1, 0
    else:
        balance, xp, level, last_time = row
    if now_ms - last_time > 30000:
        xp += 5
        balance += 2
        last_time = now_ms
        needed = level * 100
        if xp >= needed:
            level += 1
            xp -= needed
            await message.channel.send(f'ðŸŽ‰ {message.author.mention} Ù„Ù‚Ø¯ ÙˆØµÙ„Øª Ù„Ù„Ù…Ø³ØªÙˆÙ‰ {level}!')
        cursor.execute('UPDATE economy SET balance=?, xp=?, level=?, last_xp_time=? WHERE guild_id=? AND user_id=?',
                       (balance, xp, level, last_time, str(message.guild.id), str(message.author.id)))
        conn.commit()
    await bot.process_commands(message)

@tasks.loop(minutes=10)
async def cleanup_spam_cache():
    now = datetime.utcnow().timestamp()
    for key in list(user_messages.keys()):
        user_messages[key] = [t for t in user_messages[key] if now - t < SPAM_SECONDS]
        if not user_messages[key]:
            del user_messages[key]

class TicketView(discord.ui.View):
    def __init__(self, author_id: int):
        super().__init__(timeout=None)
        self.author_id = author_id

    @discord.ui.button(label='Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„ØªØ°ÙƒØ±Ø©', style=discord.ButtonStyle.red, emoji='ðŸ”’')
    async def close_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.author_id and not is_mod_check(interaction):
            await interaction.response.send_message('Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ© Ù„Ø¥ØºÙ„Ø§Ù‚ Ù‡Ø°Ù‡ Ø§Ù„ØªØ°ÙƒØ±Ø©.', ephemeral=True)
            return
        await interaction.response.send_message('Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„Ø¥ØºÙ„Ø§Ù‚ØŸ Ø§ÙƒØªØ¨ `ØªØ£ÙƒÙŠØ¯` Ø®Ù„Ø§Ù„ 15 Ø«Ø§Ù†ÙŠØ©', ephemeral=True)
        def check(m):
            return m.author.id == interaction.user.id and m.channel.id == interaction.channel.id
        try:
            msg = await bot.wait_for('message', check=check, timeout=15)
            if msg.content.lower() == 'ØªØ£ÙƒÙŠØ¯':
                await log_action(interaction.guild, f'ðŸ”’ **{interaction.user}** Ø£ØºÙ„Ù‚ Ø§Ù„ØªØ°ÙƒØ±Ø© {interaction.channel.name}')
                await interaction.channel.delete()
                cursor.execute('DELETE FROM tickets WHERE channel_id=?', (interaction.channel.id,))
                conn.commit()
            else:
                await interaction.channel.send('ØªÙ… Ø§Ù„Ø¥Ù„ØºØ§Ø¡.')
        except asyncio.TimeoutError:
            await interaction.channel.send('Ø§Ù†ØªÙ‡Øª Ø§Ù„Ù…Ù‡Ù„Ø©. ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø¥ØºÙ„Ø§Ù‚.')

@bot.tree.command(name='ticket')
@app_commands.describe(reason='Ø³Ø¨Ø¨ ÙØªØ­ Ø§Ù„ØªØ°ÙƒØ±Ø©')
async def ticket_slash(interaction: discord.Interaction, reason: str = 'Ø¨Ø¯ÙˆÙ† Ø³Ø¨Ø¨'):
    guild = interaction.guild
    member = interaction.user
    name = f'ticket-{member.name}'.lower()[:90]
    overwrites = {
        guild.default_role: discord.PermissionOverwrite(read_messages=False),
        member: discord.PermissionOverwrite(read_messages=True, send_messages=True)
    }
    channel = await guild.create_text_channel(name, overwrites=overwrites, reason=f'Ticket for {member}')
    await channel.send(f'ðŸŽ« ØªØ°ÙƒØ±Ø© Ù…Ù† {member.mention} â€” {reason}', view=TicketView(author_id=member.id))
    cursor.execute('INSERT INTO tickets (guild_id, user_id, channel_id) VALUES (?, ?, ?)',
                   (str(guild.id), str(member.id), channel.id))
    conn.commit()
    await interaction.response.send_message(f'ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ØªØ°ÙƒØ±Ø©: {channel.mention}', ephemeral=True)
    await log_action(guild, f'ðŸŽ« **{member}** ÙØªØ­ ØªØ°ÙƒØ±Ø© â€” {reason}')

@bot.tree.command(name='balance')
@app_commands.describe(user='Ø§Ø®ØªÙŠØ§Ø±ÙŠ - Ø¹Ø±Ø¶ Ø±ØµÙŠØ¯ Ù…Ø³ØªØ®Ø¯Ù…')
async def balance_slash(interaction: discord.Interaction, user: discord.User = None):
    target = user or interaction.user
    cursor.execute('SELECT balance FROM economy WHERE guild_id=? AND user_id=?', (str(interaction.guild.id), str(target.id)))
    row = cursor.fetchone()
    bal = row[0] if row else 0
    await interaction.response.send_message(f'ðŸ’° Ø±ØµÙŠØ¯ {target.mention} Ù‡Ùˆ {bal} {CB_NAME}.', ephemeral=True)

@bot.tree.command(name='pay')
@app_commands.describe(user='Ø§Ù„Ø´Ø®Øµ Ø§Ù„Ø°ÙŠ ØªØ±ÙŠØ¯ Ø§Ù„Ø¯ÙØ¹ Ù„Ù‡', amount='Ø§Ù„Ù…Ø¨Ù„Øº')
async def pay_slash(interaction: discord.Interaction, user: discord.User, amount: int):
    if amount <= 0:
        return await interaction.response.send_message('Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ù…Ø¨Ù„Øº ØµØ­ÙŠØ­ Ø£ÙƒØ¨Ø± Ù…Ù† ØµÙØ±.', ephemeral=True)
    payer_id = str(interaction.user.id)
    guild_id = str(interaction.guild.id)
    cursor.execute('SELECT balance FROM economy WHERE guild_id=? AND user_id=?', (guild_id, payer_id))
    row = cursor.fetchone()
    payer_balance = row[0] if row else 0
    if payer_balance < amount:
        return await interaction.response.send_message(f'Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø±ØµÙŠØ¯ ÙƒØ§ÙÙŠ. Ø±ØµÙŠØ¯Ùƒ Ø§Ù„Ø­Ø§Ù„ÙŠ: {payer_balance} {CB_NAME}.', ephemeral=True)
    payee_id = str(user.id)
    cursor.execute('SELECT balance FROM economy WHERE guild_id=? AND user_id=?', (guild_id, payee_id))
    row = cursor.fetchone()
    payee_balance = row[0] if row else 0
    # ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª
    cursor.execute('UPDATE economy SET balance=? WHERE guild_id=? AND user_id=?', (payer_balance - amount, guild_id, payer_id))
    if row:
        cursor.execute('UPDATE economy SET balance=? WHERE guild_id=? AND user_id=?', (payee_balance + amount, guild_id, payee_id))
    else:
        cursor.execute('INSERT INTO economy (guild_id, user_id, balance) VALUES (?, ?, ?)', (guild_id, payee_id, amount))
    conn.commit()
    await interaction.response.send_message(f'âœ… ØªÙ… ØªØ­ÙˆÙŠÙ„ {amount} {CB_NAME} Ø¥Ù„Ù‰ {user.mention}.', ephemeral=True)

# Ø£ÙˆØ§Ù…Ø± Ø¨Ø±ÙŠÙÙƒØ³ Ù…Ø´Ø§Ø¨Ù‡Ø© (Ø§Ø®ØªÙŠØ§Ø±ÙŠ Ø¥Ø¶Ø§ÙØªÙ‡Ø§)

@bot.command(name='balance')
async def balance_cmd(ctx: commands.Context, user: discord.User = None):
    target = user or ctx.author
    cursor.execute('SELECT balance FROM economy WHERE guild_id=? AND user_id=?', (str(ctx.guild.id), str(target.id)))
    row = cursor.fetchone()
    bal = row[0] if row else 0
    await ctx.reply(f'ðŸ’° Ø±ØµÙŠØ¯ {target.mention} Ù‡Ùˆ {bal} {CB_NAME}.')

@bot.command(name='pay')
async def pay_cmd(ctx: commands.Context, user: discord.User, amount: int):
    if amount <= 0:
        return await ctx.reply('Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ù…Ø¨Ù„Øº ØµØ­ÙŠØ­ Ø£ÙƒØ¨Ø± Ù…Ù† ØµÙØ±.')
    payer_id = str(ctx.author.id)
    guild_id = str(ctx.guild.id)
    cursor.execute('SELECT balance FROM economy WHERE guild_id=? AND user_id=?', (guild_id, payer_id))
    row = cursor.fetchone()
    payer_balance = row[0] if row else 0
    if payer_balance < amount:
        return await ctx.reply(f'Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø±ØµÙŠØ¯ ÙƒØ§ÙÙŠ. Ø±ØµÙŠØ¯Ùƒ Ø§Ù„Ø­Ø§Ù„ÙŠ: {payer_balance} {CB_NAME}.')
    payee_id = str(user.id)
    cursor.execute('SELECT balance FROM economy WHERE guild_id=? AND user_id=?', (guild_id, payee_id))
    row = cursor.fetchone()
    payee_balance = row[0] if row else 0
    cursor.execute('UPDATE economy SET balance=? WHERE guild_id=? AND user_id=?', (payer_balance - amount, guild_id, payer_id))
    if row:
        cursor.execute('UPDATE economy SET balance=? WHERE guild_id=? AND user_id=?', (payee_balance + amount, guild_id, payee_id))
    else:
        cursor.execute('INSERT INTO economy (guild_id, user_id, balance) VALUES (?, ?, ?)', (guild_id, payee_id, amount))
    conn.commit()
    await ctx.reply(f'âœ… ØªÙ… ØªØ­ÙˆÙŠÙ„ {amount} {CB_NAME} Ø¥Ù„Ù‰ {user.mention}.')

if __name__ == '__main__':
    try:
        bot.run(MTQwMzg1MDgxNDAwNjc1OTQ2NQ.Gg2x3P.TXjYWhBjh_FofLqYM8CKKQc-k1CdZLWa66nHqs)
